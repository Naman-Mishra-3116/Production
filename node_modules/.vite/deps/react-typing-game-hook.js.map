{
  "version": 3,
  "sources": ["../../react-typing-game-hook/src/Actions/reset.ts", "../../react-typing-game-hook/src/Actions/index.ts", "../../react-typing-game-hook/src/types.ts", "../../react-typing-game-hook/src/index.ts", "../../react-typing-game-hook/src/Actions/setCurrentIndex.ts", "../../react-typing-game-hook/src/Actions/end.ts", "../../react-typing-game-hook/src/Actions/typingInsert.ts", "../../react-typing-game-hook/src/Actions/typingDelete.ts"],
  "sourcesContent": ["import type { TypingStateType } from '../types';\n\nexport default (state: TypingStateType): TypingStateType => {\n  let { chars } = state;\n\n  return {\n    ...state,\n    startTime: null,\n    endTime: null,\n    charsState: new Array(chars.length).fill(0),\n    currIndex: -1,\n    currChar: '',\n    correctChar: 0,\n    errorChar: 0,\n    phase: 0,\n  };\n};\n", "import type { TypingStateType } from '../types';\n\nexport enum ActionType {\n  _ONTEXTCHANGE = 'INTERNAL/ONTEXTCHANGE',\n  RESET = 'RESET',\n  END = 'END',\n  TYPINGINSERT = 'TYPING/INSERT',\n  TYPINGDELETE = 'TYPING/DELETE',\n  SETCURRENTINDEX = 'SET/CURRENTINDEX',\n}\n\nexport type ActionItemType =\n  | { type: ActionType.RESET; payload?: undefined }\n  | { type: ActionType.END; payload?: undefined }\n  | { type: ActionType.TYPINGDELETE; payload: boolean }\n  | { type: ActionType.TYPINGINSERT; payload: string | null }\n  | { type: ActionType.SETCURRENTINDEX; payload: number }\n  | {type: ActionType._ONTEXTCHANGE; payload: TypingStateType}\n\nexport { default as RESET } from './reset';\nexport { default as SETCURRENTINDEX } from './setCurrentIndex';\nexport { default as END } from './end';\nexport { default as TYPINGINSERT } from './typingInsert';\nexport { default as TYPINGDELETE } from './typingDelete';\n", "type countErrorTypes = 'everytime' | 'once';\n\ntype valueof<T> = T[keyof T];\n\n/**\n * Constants for different phases.\n */\nexport const PhaseType = {\n  /**\n   * Phase when typing has yet to start.\n   */\n  NotStarted: 0,\n  /**\n   * Phase when typing has started.\n   */\n  Started: 1,\n  /**\n   * Phase when typing has ended.\n   */\n  Ended: 2,\n} as const;\n\n/**\n * Constants for different character states.\n */\nexport const CharStateType = {\n  /**\n   * Character has yet to be determined to be correct or incorrect.\n   */\n  Incomplete: 0,\n  /**\n   * Character is determined to be correct.\n   */\n  Correct: 1,\n  /**\n   * Character is determined to be incorrect.\n   */\n  Incorrect: 2,\n} as const;\n\nexport interface TypingOptionsType {\n  /**\n   * Move on to the next word when space is inputted, defaults to `true`.\n   */\n  skipCurrentWordOnSpace: boolean;\n  /**\n   * Stay on the current index when the inputted character is wrong, defaults to `false`.\n   */\n  pauseOnError: boolean;\n  /**\n   * With `everytime`, choose to count errors everytime a mistake is made.\n   * With `once`, choose to count errors only once for each mistake made.\n   */\n  countErrors: countErrorTypes;\n}\n\n/**\n * Properties of the typing game hook.\n */\nexport interface TypingStateType extends TypingOptionsType {\n  /**\n   * The inputted string to be used.\n   */\n  chars: string;\n  /**\n   * Array of each character's state in the string.\n   * Each item in the array represents the state of each character in the string.\n   * `0` represents incomplete, `1` represents correct and, `2` represents incorrect.\n   */\n  charsState: valueof<typeof CharStateType>[];\n  /**\n   * Length of the string used.\n   */\n  length: number;\n  /**\n   * Current index of the character the user have typed till.\n   */\n  currIndex: number;\n  /**\n   * Current character the user have typed till.\n   */\n  currChar: string;\n  /**\n   * Number of correct character the user had typed.\n   */\n  correctChar: number;\n  /**\n   * Number of incorrect character the user had typed.\n   */\n  errorChar: number;\n  /**\n   * Represent the current state.\n   * `0` typing haven't started, `1` typing started, `2` typing ended.\n   */\n  phase: valueof<typeof PhaseType>;\n  /**\n   * Time in milliseconds when the typing started.\n   */\n  startTime: number | null;\n  /**\n   * Time in milliseconds when the typing ended.\n   */\n  endTime: number | null;\n}\n\n/**\n * Methods of the typing game hook.\n */\nexport interface TypingActionType {\n  /**\n   * Duration in milliseconds since the typing started.\n   * 0 if the typing has yet to start.\n   * When the typing ended, the duration will be equivalent to endTime - startTime.\n   */\n  getDuration: () => number;\n  /**\n   * Reset the typing sequence.\n   */\n  resetTyping: () => void;\n  /**\n   * Ends the typing sequence but not reset it.\n   */\n  endTyping: () => void;\n  /**\n   * Insert a character into the current typing sequence.\n   * @param {string | null} char A character to be inserted.\n   * If falsy or no argument is supplied, skip the current character.\n   */\n  insertTyping: (char?: string) => void;\n  /**\n   * Delete a character from the current typing sequence.\n   * @param {boolean} [deleteWord] If `true`, deletes the whole of the current word. Defaults to `false`.\n   */\n  deleteTyping: (deleteWord?: boolean) => void;\n  /**\n   * Set the current index manually.\n   * @param {number} num Allows from -1 to length - 1 of the text, numbers that falls outside of the range will return a false.\n   */\n  setCurrIndex: (num: number) => boolean;\n}\n", "import { Reducer, useCallback, useEffect, useMemo, useReducer } from 'react';\nimport {\n  RESET,\n  SETCURRENTINDEX,\n  END,\n  TYPINGINSERT,\n  TYPINGDELETE,\n  ActionType,\n  ActionItemType,\n} from './Actions';\n\nimport {\n  CharStateType,\n  PhaseType,\n  TypingActionType,\n  TypingOptionsType,\n  TypingStateType,\n} from './types';\n\nconst reducer: Reducer<TypingStateType, ActionItemType> = (state, action) => {\n  switch (action.type) {\n    case ActionType.SETCURRENTINDEX:\n      return SETCURRENTINDEX(state, action);\n    case ActionType.RESET:\n      return RESET(state);\n    case ActionType.END:\n      return END(state);\n    case ActionType.TYPINGINSERT:\n      return TYPINGINSERT(state, action);\n    case ActionType.TYPINGDELETE:\n      return TYPINGDELETE(state, action);\n    case ActionType._ONTEXTCHANGE:\n      return action.payload;\n    default: {\n      return state;\n    }\n  }\n};\n\n/**\n * React hook to create typing challenge/game/practice/test.\n * @param {string} text A string of words to be used for the typing sequence.\n * @param {Object} [options] Addition options to customize the functionality of the typing sequence.\n * @param {boolean} [options.skipCurrentWordOnSpace] Move on to the next word when space is inputted, defaults to `true`.\n * @param {boolean} [options.pauseOnError] Stay on the current index when the inputted character is wrong, defaults to `false`.\n * @param {countErrorTypes} [options.countErrors]\n * @returns Returns the state and the actions available for the typing hook.\n */\nconst useTypingGame = (\n  text: string = '',\n  options: Partial<TypingOptionsType> = {}\n): { states: TypingStateType; actions: TypingActionType } => {\n  const initialState = useMemo<TypingStateType>(\n    () => ({\n      startTime: null,\n      endTime: null,\n      chars: text,\n      charsState: new Array(text.length).fill(0),\n      length: text.length,\n      currIndex: -1,\n      currChar: '',\n      correctChar: 0,\n      errorChar: 0,\n      phase: 0,\n      skipCurrentWordOnSpace: true,\n      pauseOnError: false,\n      countErrors: 'everytime',\n      ...options,\n    }),\n    [options, text]\n  );\n\n  const [states, dispatch] = useReducer<\n    Reducer<TypingStateType, ActionItemType>\n  >(reducer, initialState);\n\n  useEffect(() => {\n    dispatch({\n      type: ActionType._ONTEXTCHANGE,\n      payload: initialState,\n    });\n  }, [text, dispatch]);\n\n  const getDuration = useCallback<TypingActionType['getDuration']>(() => {\n    switch (states.phase) {\n      case PhaseType.NotStarted: {\n        return 0;\n      }\n      case PhaseType.Started: {\n        return states.startTime ? new Date().getTime() - states.startTime : 0;\n      }\n      case PhaseType.Ended: {\n        return states.startTime && states.endTime\n          ? states.endTime - states.startTime\n          : 0;\n      }\n    }\n  }, [states.phase, states.startTime, states.startTime]);\n\n  const resetTyping = useCallback<TypingActionType['resetTyping']>(\n    () => dispatch({ type: ActionType.RESET }),\n    [dispatch]\n  );\n\n  const endTyping = useCallback<TypingActionType['endTyping']>(\n    () => dispatch({ type: ActionType.END }),\n    [dispatch]\n  );\n\n  const insertTyping = useCallback<TypingActionType['insertTyping']>(\n    (letter: string | undefined) => {\n      const payload = letter ? letter[0] : null;\n      dispatch({\n        type: ActionType.TYPINGINSERT,\n        payload,\n      });\n    },\n    [dispatch]\n  );\n\n  const deleteTyping = useCallback<TypingActionType['deleteTyping']>(\n    (deleteWord = false) => {\n      dispatch({\n        type: ActionType.TYPINGDELETE,\n        payload: deleteWord || false,\n      });\n    },\n    [dispatch]\n  );\n\n  const setCurrIndex = useCallback<TypingActionType['setCurrIndex']>(\n    (num: number) => {\n      if (num < -1 || num >= states.length || states.phase !== 2) {\n        return false;\n      }\n      dispatch({\n        type: ActionType.SETCURRENTINDEX,\n        payload: num,\n      });\n      return true;\n    },\n    [dispatch, states.length, states.phase]\n  );\n\n  return {\n    states,\n    actions: {\n      getDuration,\n      resetTyping,\n      endTyping,\n      insertTyping,\n      deleteTyping,\n      setCurrIndex,\n    },\n  };\n};\n\nexport default useTypingGame;\n\nexport {\n  CharStateType,\n  PhaseType,\n  TypingActionType,\n  TypingOptionsType,\n  TypingStateType,\n};\n", "import { ActionItemType } from './index';\nimport type { TypingStateType } from '../types';\n\nexport default (\n  state: TypingStateType,\n  action: ActionItemType\n): TypingStateType => {\n  let { chars, length } = state;\n  let payload = action.payload ?? null;\n  if (\n    payload &&\n    typeof payload === 'number' &&\n    payload >= -1 &&\n    payload < length\n  ) {\n    return { ...state, currIndex: payload, currChar: chars[payload] };\n  } else {\n    return state;\n  }\n};\n", "import type { TypingStateType } from '../types';\n\nexport default (state: TypingStateType): TypingStateType => ({\n  ...state,\n  phase: 2,\n  endTime: new Date().getTime(),\n});\n", "import { ActionItemType } from './index';\nimport type { TypingStateType } from '../types';\n\nexport default (\n  state: TypingStateType,\n  action: ActionItemType\n): TypingStateType => {\n  let {\n    startTime,\n    endTime,\n    chars,\n    charsState,\n    length,\n    currIndex,\n    correctChar,\n    errorChar,\n    phase,\n    skipCurrentWordOnSpace,\n    pauseOnError,\n    countErrors,\n  } = state;\n  let letter = action.payload ?? null;\n  let newStartTime = startTime;\n  let newEndTime = endTime;\n  if (phase === 2) {\n    return state;\n  }\n\n  if (phase === 0) {\n    phase = 1;\n    newStartTime = new Date().getTime();\n  }\n\n  let newCharsState = [...charsState];\n  if (\n    letter === ' ' &&\n    chars[currIndex + 1] !== ' ' &&\n    skipCurrentWordOnSpace\n  ) {\n    let newIndex = chars.indexOf(letter, currIndex);\n    currIndex = newIndex === -1 ? length - 1 : newIndex;\n  } else {\n    if (letter !== null) {\n      if (chars[currIndex + 1] !== letter) {\n        if (newCharsState[currIndex + 1] == 2) {\n          if (countErrors === 'everytime') {\n            errorChar += 1;\n          }\n        } else {\n          newCharsState[currIndex + 1] = 2;\n          errorChar += 1;\n        }\n        if (!pauseOnError) {\n          currIndex += 1;\n        }\n      } else {\n        if (\n          newCharsState[currIndex + 1] === 2 &&\n          pauseOnError &&\n          countErrors === 'once'\n        ) {\n          errorChar -= 1;\n        }\n        newCharsState[currIndex + 1] = 1;\n        correctChar += 1;\n        currIndex += 1;\n      }\n    } else {\n      currIndex += 1;\n    }\n  }\n\n  if (currIndex >= length - 1) {\n    newEndTime = new Date().getTime();\n    phase = 2;\n  }\n  let currChar = currIndex >= 0 ? chars[currIndex] : '';\n  return {\n    ...state,\n    charsState: newCharsState,\n    errorChar,\n    correctChar,\n    currIndex,\n    currChar,\n    phase,\n    startTime: newStartTime,\n    endTime: newEndTime,\n  };\n};\n", "import { ActionItemType } from './index';\nimport type { TypingStateType } from '../types';\n\nexport default (\n  state: TypingStateType,\n  action: ActionItemType\n): TypingStateType => {\n  let {\n    chars,\n    charsState,\n    currIndex,\n    correctChar,\n    errorChar,\n    phase,\n    countErrors,\n  } = state;\n  let payload = action.payload ?? null;\n\n  if (phase !== 1 || currIndex === -1) {\n    return state;\n  }\n  let newCharsState = [...charsState];\n  if (payload) {\n    let newIndex = chars.lastIndexOf(' ', currIndex);\n    newIndex = newIndex === -1 ? 0 : newIndex + 1;\n    for (let i = currIndex; i >= newIndex; i--) {\n      if (newCharsState[i] === 1) {\n        correctChar -= 1;\n      } else if (newCharsState[i] === 2) {\n        if (countErrors === 'once') {\n          errorChar -= 1;\n        }\n      }\n      newCharsState[i] = 0;\n    }\n    currIndex = newIndex;\n  } else {\n    if (newCharsState[currIndex] === 1) {\n      correctChar -= 1;\n    } else if (newCharsState[currIndex] === 2) {\n      if (countErrors === 'once') {\n        errorChar -= 1;\n      }\n    }\n    newCharsState[currIndex] = 0;\n  }\n  if (currIndex !== -1) {\n    currIndex -= 1;\n  }\n  let currChar = currIndex >= 0 ? chars[currIndex] : '';\n  return {\n    ...state,\n    currIndex,\n    currChar,\n    charsState: newCharsState,\n    correctChar,\n    errorChar,\n  };\n};\n"],
  "mappings": "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",
  "names": ["ActionType", "PhaseType", "NotStarted", "Started", "Ended", "reducer", "state", "action", "type", "SETCURRENTINDEX", "chars", "length", "payload", "currIndex", "currChar", "RESET", "startTime", "endTime", "charsState", "Array", "fill", "correctChar", "errorChar", "phase", "END", "Date", "getTime", "TYPINGINSERT", "skipCurrentWordOnSpace", "pauseOnError", "countErrors", "letter", "newStartTime", "newEndTime", "newCharsState", "newIndex", "indexOf", "TYPINGDELETE", "lastIndexOf", "i", "_ONTEXTCHANGE", "Incomplete", "Correct", "Incorrect", "text", "options", "initialState", "useMemo", "_a", "useReducer", "states", "dispatch", "useEffect", "getDuration", "useCallback", "resetTyping", "endTyping", "insertTyping", "deleteTyping", "deleteWord", "setCurrIndex", "num", "actions"]
}
